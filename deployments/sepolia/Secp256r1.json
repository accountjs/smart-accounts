{
  "address": "0xb919d759B00D5501edACe18346353c0a1D7D159e",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "message",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "publicKey",
          "type": "bytes"
        }
      ],
      "name": "validateSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "result",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xa66194afee3686d1a0acdfcdc02c393e302a91877ef52c3612640a7b8d36df0b",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x962F35D2249B069B38BbE169B2A449f823b8Bf79",
    "contractAddress": null,
    "transactionIndex": 6,
    "gasUsed": "730931",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x6eaf2651b573de785d5519e1b9a2ae1e5fda6b4ce5d63bf85c38b3a38027eba9",
    "transactionHash": "0xa66194afee3686d1a0acdfcdc02c393e302a91877ef52c3612640a7b8d36df0b",
    "logs": [],
    "blockNumber": 4501152,
    "cumulativeGasUsed": "6371782",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "33e1633ade8f91f0094e41155055e934",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"}],\"name\":\"validateSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"This contract based on daimo-eth's implementation: https://github.com/daimo-eth/p256-verifier\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/validators/p256/Secp256r1.sol\":\"Secp256r1\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/validators/p256/ISecp256r1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface ISecp256r1 {\\n    function validateSignature(bytes32 message, bytes calldata signature, bytes calldata publicKey)\\n        external\\n        view\\n        returns (bool);\\n}\\n\",\"keccak256\":\"0x2c27d09b504eebfad02daf6a774b8df8bf29c51077f288bf6dd5464b4a18d177\",\"license\":\"MIT\"},\"contracts/validators/p256/Secp256r1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./ISecp256r1.sol\\\";\\n\\n/**\\n * This contract based on daimo-eth's implementation:\\n * https://github.com/daimo-eth/p256-verifier\\n */\\ncontract Secp256r1 is ISecp256r1 {\\n    function validateSignature(bytes32 message, bytes calldata signature, bytes calldata publicKey)\\n        external\\n        view\\n        override\\n        returns (bool result)\\n    {\\n        uint256[2] memory rs;\\n        (rs[0], rs[1]) = abi.decode(signature, (uint256, uint256));\\n        uint256[2] memory Q;\\n        (Q[0], Q[1]) = abi.decode(publicKey, (uint256, uint256));\\n        return ecdsa_verify(message, rs[0], rs[1], Q);\\n    }\\n\\n    // Parameters for the sec256r1 (P256) elliptic curve\\n    // Curve prime field modulus\\n    uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\n    // Short weierstrass first coefficient\\n    uint256 constant a = // The assumption a == -3 (mod p) is used throughout the codebase\\n     0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\\n    // Short weierstrass second coefficient\\n    uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\\n    // Generating point affine coordinates\\n    uint256 constant GX = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\\n    uint256 constant GY = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\\n    // Curve order (number of points)\\n    uint256 constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\\n    // -2 mod p constant, used to speed up inversion and doubling (avoid negation)\\n    uint256 constant minus_2modp = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD;\\n    // -2 mod n constant, used to speed up inversion\\n    uint256 constant minus_2modn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F;\\n\\n    /**\\n     * @dev ECDSA verification given signature and public key.\\n     */\\n    function ecdsa_verify(bytes32 message_hash, uint256 r, uint256 s, uint256[2] memory pubKey)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        // Check r and s are in the scalar field\\n        if (r == 0 || r >= n || s == 0 || s >= n) {\\n            return false;\\n        }\\n\\n        if (!ecAff_isValidPubkey(pubKey[0], pubKey[1])) {\\n            return false;\\n        }\\n\\n        uint256 sInv = nModInv(s);\\n\\n        uint256 scalar_u = mulmod(uint256(message_hash), sInv, n); // (h * s^-1) in scalar field\\n        uint256 scalar_v = mulmod(r, sInv, n); // (r * s^-1) in scalar field\\n\\n        uint256 r_x = ecZZ_mulmuladd(pubKey[0], pubKey[1], scalar_u, scalar_v);\\n        return r_x % n == r;\\n    }\\n\\n    /**\\n     * @dev Check if a point in affine coordinates is on the curve\\n     * Reject 0 point at infinity.\\n     */\\n    function ecAff_isValidPubkey(uint256 x, uint256 y) internal pure returns (bool) {\\n        if (x >= p || y >= p || (x == 0 && y == 0)) {\\n            return false;\\n        }\\n\\n        return ecAff_satisfiesCurveEqn(x, y);\\n    }\\n\\n    function ecAff_satisfiesCurveEqn(uint256 x, uint256 y) internal pure returns (bool) {\\n        uint256 LHS = mulmod(y, y, p); // y^2\\n        uint256 RHS = addmod(mulmod(mulmod(x, x, p), x, p), mulmod(a, x, p), p); // x^3 + a x\\n        RHS = addmod(RHS, b, p); // x^3 + a*x + b\\n\\n        return LHS == RHS;\\n    }\\n\\n    /**\\n     * @dev Computation of uG + vQ using Strauss-Shamir's trick, G basepoint, Q public key\\n     * returns tuple of (x coordinate of uG + vQ, boolean that is false if internal precompile staticcall fail)\\n     * Strauss-Shamir is described well in https://stackoverflow.com/a/50994362\\n     */\\n    function ecZZ_mulmuladd(\\n        uint256 QX,\\n        uint256 QY, // affine rep for input point Q\\n        uint256 scalar_u,\\n        uint256 scalar_v\\n    ) internal view returns (uint256 X) {\\n        uint256 zz = 1;\\n        uint256 zzz = 1;\\n        uint256 Y;\\n        uint256 HX;\\n        uint256 HY;\\n\\n        if (scalar_u == 0 && scalar_v == 0) return 0;\\n\\n        // H = g + Q\\n        (HX, HY) = ecAff_add(GX, GY, QX, QY);\\n\\n        int256 index = 255;\\n        uint256 bitpair;\\n\\n        // Find the first bit index that's active in either scalar_u or scalar_v.\\n        while (index >= 0) {\\n            bitpair = compute_bitpair(uint256(index), scalar_u, scalar_v);\\n            index--;\\n            if (bitpair != 0) break;\\n        }\\n\\n        // initialise (X, Y) depending on the first active bitpair.\\n        // invariant(bitpair != 0); // bitpair == 0 is only possible if u and v are 0.\\n\\n        if (bitpair == 1) {\\n            (X, Y) = (GX, GY);\\n        } else if (bitpair == 2) {\\n            (X, Y) = (QX, QY);\\n        } else if (bitpair == 3) {\\n            (X, Y) = (HX, HY);\\n        }\\n\\n        uint256 TX;\\n        uint256 TY;\\n        while (index >= 0) {\\n            (X, Y, zz, zzz) = ecZZ_double_zz(X, Y, zz, zzz);\\n\\n            bitpair = compute_bitpair(uint256(index), scalar_u, scalar_v);\\n            index--;\\n\\n            if (bitpair == 0) {\\n                continue;\\n            } else if (bitpair == 1) {\\n                (TX, TY) = (GX, GY);\\n            } else if (bitpair == 2) {\\n                (TX, TY) = (QX, QY);\\n            } else {\\n                (TX, TY) = (HX, HY);\\n            }\\n\\n            (X, Y, zz, zzz) = ecZZ_dadd_affine(X, Y, zz, zzz, TX, TY);\\n        }\\n\\n        uint256 zzInv = pModInv(zz); // If zz = 0, zzInv = 0.\\n        X = mulmod(X, zzInv, p); // X/zz\\n    }\\n\\n    /**\\n     * @dev Compute the bits at `index` of u and v and return\\n     * them as 2 bit concatenation. The bit at index 0 is on\\n     * if the `index`th bit of scalar_u is on and the bit at\\n     * index 1 is on if the `index`th bit of scalar_v is on.\\n     * Examples:\\n     * - compute_bitpair(0, 1, 1) == 3\\n     * - compute_bitpair(0, 1, 0) == 1\\n     * - compute_bitpair(0, 0, 1) == 2\\n     */\\n    function compute_bitpair(uint256 index, uint256 scalar_u, uint256 scalar_v) internal pure returns (uint256 ret) {\\n        ret = (((scalar_v >> index) & 1) << 1) + ((scalar_u >> index) & 1);\\n    }\\n\\n    /**\\n     * @dev Add two elliptic curve points in affine coordinates\\n     * Assumes points are on the EC\\n     */\\n    function ecAff_add(uint256 x1, uint256 y1, uint256 x2, uint256 y2) internal view returns (uint256, uint256) {\\n        // invariant(ecAff_IsZero(x1, y1) || ecAff_isOnCurve(x1, y1));\\n        // invariant(ecAff_IsZero(x2, y2) || ecAff_isOnCurve(x2, y2));\\n\\n        uint256 zz1;\\n        uint256 zzz1;\\n\\n        if (ecAff_IsInf(x1, y1)) return (x2, y2);\\n        if (ecAff_IsInf(x2, y2)) return (x1, y1);\\n\\n        (x1, y1, zz1, zzz1) = ecZZ_dadd_affine(x1, y1, 1, 1, x2, y2);\\n\\n        return ecZZ_SetAff(x1, y1, zz1, zzz1);\\n    }\\n\\n    /**\\n     * @dev Check if a point is the infinity point in affine rep.\\n     * Assumes point is on the EC or is the point at infinity.\\n     */\\n    function ecAff_IsInf(uint256 x, uint256 y) internal pure returns (bool flag) {\\n        // invariant((x == 0 && y == 0) || ecAff_isOnCurve(x, y));\\n\\n        return (x == 0 && y == 0);\\n    }\\n\\n    /**\\n     * @dev Check if a point is the infinity point in ZZ rep.\\n     * Assumes point is on the EC or is the point at infinity.\\n     */\\n    function ecZZ_IsInf(uint256 zz, uint256 zzz) internal pure returns (bool flag) {\\n        // invariant((zz == 0 && zzz == 0) || ecAff_isOnCurve(x, y) for affine\\n        // form of the point)\\n\\n        return (zz == 0 && zzz == 0);\\n    }\\n\\n    /**\\n     * @dev Add a ZZ point to an affine point and return as ZZ rep\\n     * Uses madd-2008-s and mdbl-2008-s internally\\n     * https://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz-3.html#addition-madd-2008-s\\n     * Matches https://github.com/supranational/blst/blob/9c87d4a09d6648e933c818118a4418349804ce7f/src/ec_ops.h#L705 closely\\n     * Handles points at infinity gracefully\\n     */\\n    function ecZZ_dadd_affine(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2)\\n        internal\\n        pure\\n        returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3)\\n    {\\n        if (ecAff_IsInf(x2, y2)) {\\n            // (X2, Y2) is point at infinity\\n            if (ecZZ_IsInf(zz1, zzz1)) return ecZZ_PointAtInf();\\n            return (x1, y1, zz1, zzz1);\\n        } else if (ecZZ_IsInf(zz1, zzz1)) {\\n            // (X1, Y1) is point at infinity\\n            return (x2, y2, 1, 1);\\n        }\\n\\n        uint256 comp_R = addmod(mulmod(y2, zzz1, p), p - y1, p); // R = S2 - y1 = y2*zzz1 - y1\\n        uint256 comp_P = addmod(mulmod(x2, zz1, p), p - x1, p); // P = U2 - x1 = x2*zz1 - x1\\n\\n        if (comp_P != 0) {\\n            // X1 != X2\\n            // invariant(x1 != x2);\\n            uint256 comp_PP = mulmod(comp_P, comp_P, p); // PP = P^2\\n            uint256 comp_PPP = mulmod(comp_PP, comp_P, p); // PPP = P*PP\\n            zz3 = mulmod(zz1, comp_PP, p); //// ZZ3 = ZZ1*PP\\n            zzz3 = mulmod(zzz1, comp_PPP, p); //// ZZZ3 = ZZZ1*PPP\\n            uint256 comp_Q = mulmod(x1, comp_PP, p); // Q = X1*PP\\n            x3 = addmod(\\n                addmod(mulmod(comp_R, comp_R, p), p - comp_PPP, p), // (R^2) + (-PPP)\\n                mulmod(minus_2modp, comp_Q, p), // (-2)*(Q)\\n                p\\n            ); // R^2 - PPP - 2*Q\\n            y3 = addmod(\\n                mulmod(addmod(comp_Q, p - x3, p), comp_R, p), //(Q+(-x3))*R\\n                mulmod(p - y1, comp_PPP, p), // (-y1)*PPP\\n                p\\n            ); // R*(Q-x3) - y1*PPP\\n        } else if (comp_R == 0) {\\n            // X1 == X2 and Y1 == Y2\\n            // invariant(x1 == x2 && y1 == y2);\\n\\n            // Must be affine because (X2, Y2) is affine.\\n            (x3, y3, zz3, zzz3) = ecZZ_double_affine(x2, y2);\\n        } else {\\n            // X1 == X2 and Y1 == -Y2\\n            // invariant(x1 == x2 && y1 == p - y2);\\n            (x3, y3, zz3, zzz3) = ecZZ_PointAtInf();\\n        }\\n\\n        return (x3, y3, zz3, zzz3);\\n    }\\n\\n    /**\\n     * @dev Double a ZZ point\\n     * Uses http://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz.html#doubling-dbl-2008-s-1\\n     * Handles point at infinity gracefully\\n     */\\n    function ecZZ_double_zz(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1)\\n        internal\\n        pure\\n        returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3)\\n    {\\n        if (ecZZ_IsInf(zz1, zzz1)) return ecZZ_PointAtInf();\\n\\n        uint256 comp_U = mulmod(2, y1, p); // U = 2*Y1\\n        uint256 comp_V = mulmod(comp_U, comp_U, p); // V = U^2\\n        uint256 comp_W = mulmod(comp_U, comp_V, p); // W = U*V\\n        uint256 comp_S = mulmod(x1, comp_V, p); // S = X1*V\\n        uint256 comp_M = addmod(mulmod(3, mulmod(x1, x1, p), p), mulmod(a, mulmod(zz1, zz1, p), p), p); //M = 3*(X1)^2 + a*(zz1)^2\\n\\n        x3 = addmod(mulmod(comp_M, comp_M, p), mulmod(minus_2modp, comp_S, p), p); // M^2 + (-2)*S\\n        y3 = addmod(mulmod(comp_M, addmod(comp_S, p - x3, p), p), mulmod(p - comp_W, y1, p), p); // M*(S+(-X3)) + (-W)*Y1\\n        zz3 = mulmod(comp_V, zz1, p); // V*ZZ1\\n        zzz3 = mulmod(comp_W, zzz1, p); // W*ZZZ1\\n    }\\n\\n    /**\\n     * @dev Double an affine point and return as a ZZ point\\n     * Uses http://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz.html#doubling-mdbl-2008-s-1\\n     * Handles point at infinity gracefully\\n     */\\n    function ecZZ_double_affine(uint256 x1, uint256 y1)\\n        internal\\n        pure\\n        returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3)\\n    {\\n        if (ecAff_IsInf(x1, y1)) return ecZZ_PointAtInf();\\n\\n        uint256 comp_U = mulmod(2, y1, p); // U = 2*Y1\\n        zz3 = mulmod(comp_U, comp_U, p); // V = U^2 = zz3\\n        zzz3 = mulmod(comp_U, zz3, p); // W = U*V = zzz3\\n        uint256 comp_S = mulmod(x1, zz3, p); // S = X1*V\\n        uint256 comp_M = addmod(mulmod(3, mulmod(x1, x1, p), p), a, p); // M = 3*(X1)^2 + a\\n\\n        x3 = addmod(mulmod(comp_M, comp_M, p), mulmod(minus_2modp, comp_S, p), p); // M^2 + (-2)*S\\n        y3 = addmod(mulmod(comp_M, addmod(comp_S, p - x3, p), p), mulmod(p - zzz3, y1, p), p); // M*(S+(-X3)) + (-W)*Y1\\n    }\\n\\n    /**\\n     * @dev Convert from ZZ rep to affine rep\\n     * Assumes (zz)^(3/2) == zzz (i.e. zz == z^2 and zzz == z^3)\\n     * See https://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz-3.html\\n     */\\n    function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz)\\n        internal\\n        view\\n        returns (uint256 x1, uint256 y1)\\n    {\\n        if (ecZZ_IsInf(zz, zzz)) {\\n            (x1, y1) = ecAffine_PointAtInf();\\n            return (x1, y1);\\n        }\\n\\n        uint256 zzzInv = pModInv(zzz); // 1 / zzz\\n        uint256 zInv = mulmod(zz, zzzInv, p); // 1 / z\\n        uint256 zzInv = mulmod(zInv, zInv, p); // 1 / zz\\n\\n        // invariant(mulmod(FCL_pModInv(zInv), FCL_pModInv(zInv), p) == zz)\\n        // invariant(mulmod(mulmod(FCL_pModInv(zInv), FCL_pModInv(zInv), p), FCL_pModInv(zInv), p) == zzz)\\n\\n        x1 = mulmod(x, zzInv, p); // X / zz\\n        y1 = mulmod(y, zzzInv, p); // y = Y / zzz\\n    }\\n\\n    /**\\n     * @dev Point at infinity in ZZ rep\\n     */\\n    function ecZZ_PointAtInf() internal pure returns (uint256, uint256, uint256, uint256) {\\n        return (0, 0, 0, 0);\\n    }\\n\\n    /**\\n     * @dev Point at infinity in affine rep\\n     */\\n    function ecAffine_PointAtInf() internal pure returns (uint256, uint256) {\\n        return (0, 0);\\n    }\\n\\n    /**\\n     * @dev u^-1 mod n\\n     */\\n    function nModInv(uint256 u) internal view returns (uint256) {\\n        return modInv(u, n, minus_2modn);\\n    }\\n\\n    /**\\n     * @dev u^-1 mod p\\n     */\\n    function pModInv(uint256 u) internal view returns (uint256) {\\n        return modInv(u, p, minus_2modp);\\n    }\\n\\n    /**\\n     * @dev u^-1 mod f = u^(phi(f) - 1) mod f = u^(f-2) mod f for prime f\\n     * by Fermat's little theorem, compute u^(f-2) mod f using modexp precompile\\n     * Assume f != 0. If u is 0, then u^-1 mod f is undefined mathematically,\\n     * but this function returns 0.\\n     */\\n    function modInv(uint256 u, uint256 f, uint256 minus_2modf) internal view returns (uint256 result) {\\n        // invariant(f != 0);\\n        // invariant(f prime);\\n\\n        // This seems like a relatively standard way to use this precompile:\\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3298/files#diff-489d4519a087ca2c75be3315b673587abeca3b302f807643e97efa7de8cb35a5R427\\n\\n        (bool success, bytes memory ret) = (address(0x05).staticcall(abi.encode(32, 32, 32, u, minus_2modf, f)));\\n        assert(success); // precompile should never fail on regular EVM environments\\n        result = abi.decode(ret, (uint256));\\n    }\\n}\\n\",\"keccak256\":\"0x0dc3333ea751de04998b21ba80d5b45e25d82913705b2187149964d9656b41c8\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001657610c3f908161001c8239f35b600080fdfe60e080604052600436101561001357600080fd5b600090813560e01c63ae7e17f01461002a57600080fd5b346100e55760603660031901126100e55767ffffffffffffffff906024358281116100e15761005d9036906004016100e9565b9290936044359182116100de5760206100d48686866100c261009e6100853660048b016100e9565b9590946100918561011c565b604036863781019061018c565b93908784019485528352604051946100b58661011c565b604036873781019061018c565b868501528352519051906004356101a2565b6040519015158152f35b80fd5b8380fd5b5080fd5b9181601f840112156101175782359167ffffffffffffffff8311610117576020838186019501011161011757565b600080fd5b6040810190811067ffffffffffffffff82111761013857604052565b634e487b7160e01b600052604160045260246000fd5b60e0810190811067ffffffffffffffff82111761013857604052565b90601f8019910116810190811067ffffffffffffffff82111761013857604052565b9190826040910312610117576020823592013590565b90928315801561033a575b8015610332575b8015610308575b6102ff5780519060206101d381830193845190610364565b156102f457604051948186019082825282604088015282606088015260808701527fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63254f60a08701527fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551958660c082015260c0815261024f8161014e565b600080928192519060055afa903d156102ec573d9167ffffffffffffffff83116102d8576040519261028a601f8201601f191686018561016a565b83523d828585013e5b156102c45782828051810103126100de5750015190516102bf939291859081818909940991519061042d565b061490565b634e487b7160e01b81526001600452602490fd5b634e487b7160e01b82526041600452602482fd5b606091610293565b505050505050600090565b50505050600090565b507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518310156101bb565b5082156101b4565b507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518410156101ad565b600160601b63ffffffff60c01b0319908181108015906103fb575b80156103ea575b6103e2577f5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b8282818080957fffffffff00000001000000000000000000000000fffffffffffffffffffffffc0991818180090908089180091490565b505050600090565b508015801561038657508215610386565b508183101561037f565b600160ff1b8114610417576000190190565b634e487b7160e01b600052601160045260246000fd5b6080848152600160a08181529690959194939160009182918891839188159081610649575b5061063b57908a9291610465878961066d565b9590968b60c09660ff88528c865b895190888212610632575061048b9082855191610652565b926104968a51610405565b8a52836104a35792610473565b50505b518103610604575050507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5907f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2969093915b838651126105d757928d6105138c948f97948f9784519161099e565b90819392939981865261052c8c869a869c519151610652565b906105378d51610405565b8d528161054f57505050505050505b929093916104f7565b9193959a508092949699506105b2979850146000146105be57507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5937f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2969361086d565b93929395529192610546565b6002036105ce578b938d9361086d565b89938b9361086d565b509950505098945050505050600160601b63ffffffff60c01b031993506105ff915051610b6c565b900990565b6002810361061a575050508690889093916104f7565b91939092916002190161054657879350869250610546565b935050506104a6565b995097505050505050505090565b90501538610452565b91906002600192841c831b16921c1681018091116104175790565b8015806106db575b6106935761068f91610686916106e3565b92919091610b1e565b9091565b50507f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296907f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f590565b508115610675565b9190821580610865575b1561073f57507f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c29691507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5906001908190565b7fb01cbd1c01e58065711814b583f061e9d431cca994cea1313449bf97c840ae0a91600160601b63ffffffff60c01b0319808481600186090894817f94e82e0c1ed3bdb90743191a9c5bbf0d88fc827fd214cc5f0b5ec6ba27673d69816001840908938415610836575050808084800993840994818460010994828088600109957f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c29609918784038481116104175784908180867bfffffffeffffffffffffffffffffffff00000000000000000000000219099181858009080897888503858111610417578580949281930994080908935b93929190565b935093505092156000146108565761084d91610a5e565b91939092610830565b50506000806000926000610830565b5080156106ed565b91949592939095811580610996575b156108ac5750508315806108a4575b6108955793929190565b50600093508392508291508190565b50821561088b565b8591929495158061098e575b61097e57600160601b63ffffffff60c01b0319968703918783116104175787838189850908938689038981116104175789908184840908928315610963575050818880959493928180848196099b8c9485099b8c920999099609918784038481116104175784908180867bfffffffeffffffffffffffffffffffff00000000000000000000000219099181858009080897888503858111610417578580949281930994080908929190565b96509650505050909350156000146108565761084d91610a5e565b9550509150915091906001908190565b5085156108b8565b50801561087c565b939092821580610a56575b61089557600160601b63ffffffff60c01b0319908185600209948280878009809709948380888a0998818080808680097fffffffff00000001000000000000000000000000fffffffffffffffffffffffc099280096003090884808a7bfffffffeffffffffffffffffffffffff0000000000000000000000021909818380090898898603918683116104175788870390878211610417578780969481809681950994089009089609930990565b5080156109a9565b919091801580610b16575b610b0957600160601b63ffffffff60c01b031990818460020991808084800980940991817fffffffff00000001000000000000000000000000fffffffffffffffffffffffc81808088860994800960030908958280837bfffffffeffffffffffffffffffffffff00000000000000000000000219098189800908968784039184831161041757858503928584116104175785809492819309940890090892565b5060009150819081908190565b508215610a69565b909392821580610b64575b610b5757610b3690610b6c565b918291600160601b63ffffffff60c01b031980809581940980099009930990565b5050509050600090600090565b508015610b29565b604051906020918281019183835283604083015283606083015260808201527bfffffffeffffffffffffffffffffffff0000000000000000000000021960a0820152600160601b63ffffffff60c01b031960c082015260c08152610bcf8161014e565b600080928192519060055afa903d15610c2a573d9167ffffffffffffffff83116102d85760405192610c0a601f8201601f191686018561016a565b83523d828585013e5b156102c45782828051810103126100de5750015190565b606091610c1356fea164736f6c6343000813000a",
  "deployedBytecode": "0x60e080604052600436101561001357600080fd5b600090813560e01c63ae7e17f01461002a57600080fd5b346100e55760603660031901126100e55767ffffffffffffffff906024358281116100e15761005d9036906004016100e9565b9290936044359182116100de5760206100d48686866100c261009e6100853660048b016100e9565b9590946100918561011c565b604036863781019061018c565b93908784019485528352604051946100b58661011c565b604036873781019061018c565b868501528352519051906004356101a2565b6040519015158152f35b80fd5b8380fd5b5080fd5b9181601f840112156101175782359167ffffffffffffffff8311610117576020838186019501011161011757565b600080fd5b6040810190811067ffffffffffffffff82111761013857604052565b634e487b7160e01b600052604160045260246000fd5b60e0810190811067ffffffffffffffff82111761013857604052565b90601f8019910116810190811067ffffffffffffffff82111761013857604052565b9190826040910312610117576020823592013590565b90928315801561033a575b8015610332575b8015610308575b6102ff5780519060206101d381830193845190610364565b156102f457604051948186019082825282604088015282606088015260808701527fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63254f60a08701527fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551958660c082015260c0815261024f8161014e565b600080928192519060055afa903d156102ec573d9167ffffffffffffffff83116102d8576040519261028a601f8201601f191686018561016a565b83523d828585013e5b156102c45782828051810103126100de5750015190516102bf939291859081818909940991519061042d565b061490565b634e487b7160e01b81526001600452602490fd5b634e487b7160e01b82526041600452602482fd5b606091610293565b505050505050600090565b50505050600090565b507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518310156101bb565b5082156101b4565b507fffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc6325518410156101ad565b600160601b63ffffffff60c01b0319908181108015906103fb575b80156103ea575b6103e2577f5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b8282818080957fffffffff00000001000000000000000000000000fffffffffffffffffffffffc0991818180090908089180091490565b505050600090565b508015801561038657508215610386565b508183101561037f565b600160ff1b8114610417576000190190565b634e487b7160e01b600052601160045260246000fd5b6080848152600160a08181529690959194939160009182918891839188159081610649575b5061063b57908a9291610465878961066d565b9590968b60c09660ff88528c865b895190888212610632575061048b9082855191610652565b926104968a51610405565b8a52836104a35792610473565b50505b518103610604575050507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5907f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2969093915b838651126105d757928d6105138c948f97948f9784519161099e565b90819392939981865261052c8c869a869c519151610652565b906105378d51610405565b8d528161054f57505050505050505b929093916104f7565b9193959a508092949699506105b2979850146000146105be57507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5937f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c2969361086d565b93929395529192610546565b6002036105ce578b938d9361086d565b89938b9361086d565b509950505098945050505050600160601b63ffffffff60c01b031993506105ff915051610b6c565b900990565b6002810361061a575050508690889093916104f7565b91939092916002190161054657879350869250610546565b935050506104a6565b995097505050505050505090565b90501538610452565b91906002600192841c831b16921c1681018091116104175790565b8015806106db575b6106935761068f91610686916106e3565b92919091610b1e565b9091565b50507f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296907f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f590565b508115610675565b9190821580610865575b1561073f57507f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c29691507f4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5906001908190565b7fb01cbd1c01e58065711814b583f061e9d431cca994cea1313449bf97c840ae0a91600160601b63ffffffff60c01b0319808481600186090894817f94e82e0c1ed3bdb90743191a9c5bbf0d88fc827fd214cc5f0b5ec6ba27673d69816001840908938415610836575050808084800993840994818460010994828088600109957f6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c29609918784038481116104175784908180867bfffffffeffffffffffffffffffffffff00000000000000000000000219099181858009080897888503858111610417578580949281930994080908935b93929190565b935093505092156000146108565761084d91610a5e565b91939092610830565b50506000806000926000610830565b5080156106ed565b91949592939095811580610996575b156108ac5750508315806108a4575b6108955793929190565b50600093508392508291508190565b50821561088b565b8591929495158061098e575b61097e57600160601b63ffffffff60c01b0319968703918783116104175787838189850908938689038981116104175789908184840908928315610963575050818880959493928180848196099b8c9485099b8c920999099609918784038481116104175784908180867bfffffffeffffffffffffffffffffffff00000000000000000000000219099181858009080897888503858111610417578580949281930994080908929190565b96509650505050909350156000146108565761084d91610a5e565b9550509150915091906001908190565b5085156108b8565b50801561087c565b939092821580610a56575b61089557600160601b63ffffffff60c01b0319908185600209948280878009809709948380888a0998818080808680097fffffffff00000001000000000000000000000000fffffffffffffffffffffffc099280096003090884808a7bfffffffeffffffffffffffffffffffff0000000000000000000000021909818380090898898603918683116104175788870390878211610417578780969481809681950994089009089609930990565b5080156109a9565b919091801580610b16575b610b0957600160601b63ffffffff60c01b031990818460020991808084800980940991817fffffffff00000001000000000000000000000000fffffffffffffffffffffffc81808088860994800960030908958280837bfffffffeffffffffffffffffffffffff00000000000000000000000219098189800908968784039184831161041757858503928584116104175785809492819309940890090892565b5060009150819081908190565b508215610a69565b909392821580610b64575b610b5757610b3690610b6c565b918291600160601b63ffffffff60c01b031980809581940980099009930990565b5050509050600090600090565b508015610b29565b604051906020918281019183835283604083015283606083015260808201527bfffffffeffffffffffffffffffffffff0000000000000000000000021960a0820152600160601b63ffffffff60c01b031960c082015260c08152610bcf8161014e565b600080928192519060055afa903d15610c2a573d9167ffffffffffffffff83116102d85760405192610c0a601f8201601f191686018561016a565b83523d828585013e5b156102c45782828051810103126100de5750015190565b606091610c1356fea164736f6c6343000813000a",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "This contract based on daimo-eth's implementation: https://github.com/daimo-eth/p256-verifier",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}