{
  "language": "Solidity",
  "sources": {
    "contracts/validators/p256/ISecp256r1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface ISecp256r1 {\n    function validateSignature(bytes32 message, bytes calldata signature, bytes calldata publicKey)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/validators/p256/Secp256r1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"./ISecp256r1.sol\";\n\ncontract Secp256r1 is ISecp256r1 {\n    struct JPoint {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n    }\n\n    uint256 constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    uint256 public constant pp = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n\n    uint256 public constant nn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n    uint256 constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    uint256 constant MOST_SIGNIFICANT = 0xc000000000000000000000000000000000000000000000000000000000000000;\n\n    function verifyWithPrecompute(JPoint[16] memory points, uint256 r, uint256 s, uint256 e)\n        internal\n        view\n        returns (bool)\n    {\n        if (r >= nn || s >= nn) {\n            return false;\n        }\n\n        uint256 w = _primemod(s, nn);\n\n        uint256 u1 = mulmod(e, w, nn);\n        uint256 u2 = mulmod(r, w, nn);\n\n        uint256 x;\n        uint256 y;\n\n        (x, y) = ShamirMultJacobian(points, u1, u2);\n        return (x == r);\n    }\n\n    /*\n     * Strauss Shamir trick for EC multiplication\n     * https://stackoverflow.com/questions/50993471/ec-scalar-multiplication-with-strauss-shamir-method\n     * we optimise on this a bit to do with 2 bits at a time rather than a single bit\n     * the individual points for a single pass are precomputed\n     * overall this reduces the number of additions while keeping the same number of doublings\n     */\n    function ShamirMultJacobian(JPoint[16] memory points, uint256 u1, uint256 u2)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        uint256 x = 0;\n        uint256 y = 0;\n        uint256 z = 0;\n        uint256 bits = 128;\n        uint256 index = 0;\n\n        while (bits > 0) {\n            if (z > 0) {\n                (x, y, z) = _modifiedJacobianDouble(x, y, z);\n                (x, y, z) = _modifiedJacobianDouble(x, y, z);\n            }\n            index = ((u1 & MOST_SIGNIFICANT) >> 252) | ((u2 & MOST_SIGNIFICANT) >> 254);\n            if (index > 0) {\n                (x, y, z) = _jAdd(x, y, z, points[index].x, points[index].y, points[index].z);\n            }\n            u1 <<= 2;\n            u2 <<= 2;\n            bits--;\n        }\n        (x, y) = _affineFromJacobian(x, y, z);\n        return (x, y);\n    }\n\n    function _preComputeJacobianPoints(uint256 x, uint256 y) internal pure returns (JPoint[16] memory points) {\n        points[0] = JPoint(0, 0, 0);\n        points[1] = JPoint(x, y, 1); // u2\n        points[2] = _jPointDouble(points[1]);\n        points[3] = _jPointAdd(points[1], points[2]);\n\n        points[4] = JPoint(gx, gy, 1); // u1Points[1]\n        points[5] = _jPointAdd(points[4], points[1]);\n        points[6] = _jPointAdd(points[4], points[2]);\n        points[7] = _jPointAdd(points[4], points[3]);\n\n        points[8] = _jPointDouble(points[4]); // u1Points[2]\n        points[9] = _jPointAdd(points[8], points[1]);\n        points[10] = _jPointAdd(points[8], points[2]);\n        points[11] = _jPointAdd(points[8], points[3]);\n\n        points[12] = _jPointAdd(points[4], points[8]); // u1Points[3]\n        points[13] = _jPointAdd(points[12], points[1]);\n        points[14] = _jPointAdd(points[12], points[2]);\n        points[15] = _jPointAdd(points[12], points[3]);\n    }\n\n    function _jPointAdd(JPoint memory p1, JPoint memory p2) internal pure returns (JPoint memory) {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n        (x, y, z) = _jAdd(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);\n        return JPoint(x, y, z);\n    }\n\n    function _jPointDouble(JPoint memory p) internal pure returns (JPoint memory) {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n        (x, y, z) = _modifiedJacobianDouble(p.x, p.y, p.z);\n        return JPoint(x, y, z);\n    }\n\n    /* _affineFromJacobian\n     * @desription returns affine coordinates from a jacobian input follows\n     * golang elliptic/crypto library\n     */\n    function _affineFromJacobian(uint256 x, uint256 y, uint256 z) internal view returns (uint256 ax, uint256 ay) {\n        if (z == 0) {\n            return (0, 0);\n        }\n\n        uint256 zinv = _primemod(z, pp);\n        uint256 zinvsq = mulmod(zinv, zinv, pp);\n\n        ax = mulmod(x, zinvsq, pp);\n        ay = mulmod(y, mulmod(zinvsq, zinv, pp), pp);\n    }\n\n    /*\n     * _jAdd\n     * @description performs double Jacobian as defined below:\n     * https://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-3/doubling/mdbl-2007-bl.op3\n     */\n    function _jAdd(uint256 p1, uint256 p2, uint256 p3, uint256 q1, uint256 q2, uint256 q3)\n        internal\n        pure\n        returns (uint256 r1, uint256 r2, uint256 r3)\n    {\n        if (p3 == 0) {\n            r1 = q1;\n            r2 = q2;\n            r3 = q3;\n\n            return (r1, r2, r3);\n        } else if (q3 == 0) {\n            r1 = p1;\n            r2 = p2;\n            r3 = p3;\n\n            return (r1, r2, r3);\n        }\n\n        assembly {\n            let pd := 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\n            let z1z1 := mulmod(p3, p3, pd) // Z1Z1 = Z1^2\n            let z2z2 := mulmod(q3, q3, pd) // Z2Z2 = Z2^2\n\n            let u1 := mulmod(p1, z2z2, pd) // U1 = X1*Z2Z2\n            let u2 := mulmod(q1, z1z1, pd) // U2 = X2*Z1Z1\n\n            let s1 := mulmod(p2, mulmod(z2z2, q3, pd), pd) // S1 = Y1*Z2*Z2Z2\n            let s2 := mulmod(q2, mulmod(z1z1, p3, pd), pd) // S2 = Y2*Z1*Z1Z1\n\n            let p3q3 := addmod(p3, q3, pd)\n\n            if lt(u2, u1) { u2 := add(pd, u2) } // u2 = u2+pd\n\n            let h := sub(u2, u1) // H = U2-U1\n\n            let i := mulmod(0x02, h, pd)\n            i := mulmod(i, i, pd) // I = (2*H)^2\n\n            let j := mulmod(h, i, pd) // J = H*I\n            if lt(s2, s1) { s2 := add(pd, s2) } // u2 = u2+pd\n\n            let rr := mulmod(0x02, sub(s2, s1), pd) // r = 2*(S2-S1)\n            r1 := mulmod(rr, rr, pd) // X3 = R^2\n\n            let v := mulmod(u1, i, pd) // V = U1*I\n            let j2v := addmod(j, mulmod(0x02, v, pd), pd)\n            if lt(r1, j2v) { r1 := add(pd, r1) } // X3 = X3+pd\n\n            r1 := sub(r1, j2v)\n\n            // Y3 = r*(V-X3)-2*S1*J\n            let s12j := mulmod(mulmod(0x02, s1, pd), j, pd)\n\n            if lt(v, r1) { v := add(pd, v) }\n            r2 := mulmod(rr, sub(v, r1), pd)\n\n            if lt(r2, s12j) { r2 := add(pd, r2) }\n            r2 := sub(r2, s12j)\n\n            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H\n            z1z1 := addmod(z1z1, z2z2, pd)\n            j2v := mulmod(p3q3, p3q3, pd)\n            if lt(j2v, z1z1) { j2v := add(pd, j2v) }\n            r3 := mulmod(sub(j2v, z1z1), h, pd)\n        }\n        return (r1, r2, r3);\n    }\n\n    // Point doubling on the modified jacobian coordinates\n    // http://point-at-infinity.org/ecc/Prime_Curve_Modified_Jacobian_Coordinates.html\n    function _modifiedJacobianDouble(uint256 x, uint256 y, uint256 z)\n        internal\n        pure\n        returns (uint256 x3, uint256 y3, uint256 z3)\n    {\n        assembly {\n            let pd := 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\n            let z2 := mulmod(z, z, pd)\n            let az4 :=\n                mulmod(0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC, mulmod(z2, z2, pd), pd)\n            let y2 := mulmod(y, y, pd)\n            let s := mulmod(0x04, mulmod(x, y2, pd), pd)\n            let u := mulmod(0x08, mulmod(y2, y2, pd), pd)\n            let m := addmod(mulmod(0x03, mulmod(x, x, pd), pd), az4, pd)\n            let twos := mulmod(0x02, s, pd)\n            let m2 := mulmod(m, m, pd)\n            if lt(m2, twos) { m2 := add(pd, m2) }\n            x3 := sub(m2, twos)\n            if lt(s, x3) { s := add(pd, s) }\n            y3 := mulmod(m, sub(s, x3), pd)\n            if lt(y3, u) { y3 := add(pd, y3) }\n            y3 := sub(y3, u)\n            z3 := mulmod(0x02, mulmod(y, z, pd), pd)\n        }\n    }\n\n    // Fermats little theorem https://en.wikipedia.org/wiki/Fermat%27s_little_theorem\n    // a^(p-1) = 1 mod p\n    // a^(-1) â‰… a^(p-2) (mod p)\n    // we then use the precompile bigModExp to compute a^(-1)\n    function _primemod(uint256 value, uint256 p) internal view returns (uint256 ret) {\n        ret = modexp(value, p - 2, p);\n        return ret;\n    }\n\n    // Wrapper for built-in BigNumber_modexp (contract 0x5) as described here. https://github.com/ethereum/EIPs/pull/198\n    function modexp(uint256 _base, uint256 _exp, uint256 _mod) internal view returns (uint256 ret) {\n        // bigModExp(_base, _exp, _mod);\n        assembly {\n            if gt(_base, _mod) { _base := mod(_base, _mod) }\n            // Free memory pointer is always stored at 0x40\n            let freemem := mload(0x40)\n\n            mstore(freemem, 0x20)\n            mstore(add(freemem, 0x20), 0x20)\n            mstore(add(freemem, 0x40), 0x20)\n\n            mstore(add(freemem, 0x60), _base)\n            mstore(add(freemem, 0x80), _exp)\n            mstore(add(freemem, 0xa0), _mod)\n\n            let success := staticcall(1500, 0x5, freemem, 0xc0, freemem, 0x20)\n            switch success\n            case 0 { revert(0x0, 0x0) }\n            default { ret := mload(freemem) }\n        }\n    }\n\n    function validateSignature(bytes32 message, bytes calldata signature, bytes calldata publicKey)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256[2] memory rs;\n        (rs[0], rs[1]) = abi.decode(signature, (uint256, uint256));\n        if (rs[0] >= nn || rs[1] >= nn || rs[0] == 0 || rs[1] == 0) {\n            //check <n and that sig is not null, otherwise (0,0) is accepted for any publickey and message\n            return false;\n        }\n\n        uint256[2] memory Q;\n        (Q[0], Q[1]) = abi.decode(publicKey, (uint256, uint256));\n\n        JPoint[16] memory points = _preComputeJacobianPoints(Q[0], Q[1]);\n        return verifyWithPrecompute(points, rs[0], rs[1], uint256(message));\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": false,
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}